<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>DOCX Cleaner Dashboard</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 2em;
      background: #f4f4f4;
    }
    h1 {
      color: #333;
    }
    input[type="file"] {
      margin-top: 1em;
    }
    button {
      margin-top: 1em;
      padding: 10px 20px;
      border: none;
      background: #007bff;
      color: white;
      cursor: pointer;
      border-radius: 5px;
    }
    button:hover {
      background: #0056b3;
    }
    #status {
      margin-top: 2em;
      font-weight: bold;
      color: green;
    }
  </style>
</head>
<body>
  <h1>üìÑ T·∫£i file DOCX ƒë·ªÉ x·ª≠ l√Ω t·ª± ƒë·ªông</h1>
  <input type="file" id="fileInput" accept=".docx" multiple />
  <br/>
  <button onclick="uploadFiles()">T·∫£i l√™n & B·∫Øt ƒë·∫ßu x·ª≠ l√Ω</button>

  <p id="status"></p>

  <button id="downloadBtn" onclick="downloadResult()" style="display: none;">‚¨áÔ∏è T·∫£i file k·∫øt qu·∫£ training_data.txt</button>

  <script>
    const GITHUB_TOKEN = "ghp_xxx"; // Thay b·∫±ng token GitHub c·ªßa b·∫°n
    const REPO = "raydoanhuy/docx-cleaner";

    async function uploadFiles() {
      const files = document.getElementById("fileInput").files;
      const statusEl = document.getElementById("status");
      const downloadBtn = document.getElementById("downloadBtn");
      statusEl.textContent = "ƒêang t·∫£i file l√™n GitHub...";

      if (!files.length) {
        statusEl.textContent = "Vui l√≤ng ch·ªçn √≠t nh·∫•t 1 file DOCX.";
        return;
      }

      try {
        for (let file of files) {
          const content = await file.arrayBuffer();
          const base64 = btoa(String.fromCharCode(...new Uint8Array(content)));

          const path = `uploads/${file.name}`;
          const url = `https://api.github.com/repos/${REPO}/contents/${path}`;
          const res = await fetch(url, {
            method: "PUT",
            headers: {
              "Authorization": `Bearer ${GITHUB_TOKEN}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              message: `Th√™m file ${file.name}`,
              content: base64
            })
          });

          if (!res.ok) {
            throw new Error(`L·ªói khi t·∫£i file ${file.name}: ${res.statusText}`);
          }
        }

        statusEl.textContent = "T·∫£i l√™n th√†nh c√¥ng! ƒêang kh·ªüi ƒë·ªông workflow...";
        await triggerWorkflow();
        checkWorkflowStatus();
        downloadBtn.style.display = "none";
      } catch (error) {
        statusEl.textContent = `L·ªói: ${error.message}`;
      }
    }

    async function triggerWorkflow() {
      const response = await fetch(`https://api.github.com/repos/${REPO}/actions/workflows/clean.yml/dispatches`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${GITHUB_TOKEN}`,
          "Accept": "application/vnd.github.v3+json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          ref: "main"
        })
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`Kh√¥ng th·ªÉ kh·ªüi ch·∫°y workflow: ${errorData.message || response.statusText}`);
      }
    }

    async function checkWorkflowStatus() {
      const statusEl = document.getElementById("status");
      try {
        const response = await fetch(`https://api.github.com/repos/${REPO}/actions/workflows/clean.yml/runs`, {
          headers: {
            "Authorization": `Bearer ${GITHUB_TOKEN}`
          }
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(`Ki·ªÉm tra workflow th·∫•t b·∫°i: ${errorData.message || response.statusText}`);
        }

        const data = await response.json();
        const latestRun = data.workflow_runs?.[0];

        if (!latestRun) {
          statusEl.textContent = "Kh√¥ng t√¨m th·∫•y workflow n√†o g·∫ßn ƒë√¢y.";
          return;
        }

        const runStatus = latestRun.status;
        const conclusion = latestRun.conclusion;

        if (runStatus !== "completed") {
          statusEl.textContent = `Workflow ƒëang ch·∫°y... Vui l√≤ng ƒë·ª£i (tr·∫°ng th√°i: ${runStatus})`;
          setTimeout(checkWorkflowStatus, 10000); // Ki·ªÉm tra l·∫°i sau 10 gi√¢y
        } else if (conclusion === "success") {
          statusEl.textContent = "‚úÖ X·ª≠ l√Ω ho√†n t·∫•t! B·∫°n c√≥ th·ªÉ t·∫£i training_data.txt.";
          document.getElementById("downloadBtn").style.display = "block";
        } else {
          statusEl.textContent = `‚ö†Ô∏è Workflow k·∫øt th√∫c nh∆∞ng kh√¥ng th√†nh c√¥ng. K·∫øt lu·∫≠n: ${conclusion}`;
        }
      } catch (error) {
        statusEl.textContent = `L·ªói ki·ªÉm tra workflow: ${error.message}`;
      }
    }

    async function downloadResult() {
      const statusEl = document.getElementById("status");
      try {
        const res = await fetch(`https://raw.githubusercontent.com/${REPO}/main/training_data.txt`, {
          headers: {
            "Authorization": `Bearer ${GITHUB_TOKEN}`
          }
        });

        if (!res.ok) {
          throw new Error(`Kh√¥ng t√¨m th·∫•y file training_data.txt: ${res.statusText}`);
        }

        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "training_data.txt";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        statusEl.textContent = "üìÅ ƒê√£ t·∫£i file training_data.txt v·ªÅ m√°y.";
      } catch (error) {
        statusEl.textContent = `L·ªói khi t·∫£i file: ${error.message}`;
      }
    }
  </script>
</body>
</html>
